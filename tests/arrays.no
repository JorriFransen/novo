
// Test returning array from #run

#import "c"

//  ma :: (v0: int) -> [2]int {
//      return { v0, 22 };
//  }

//  main :: () -> int {
//      a := ma(11);

//      printf("a: { %i, %i }\n".data, a[0], a[1]);
//      return 0;
//  }

main :: () -> int {

    a1 : [2]int; // Local allocation, uninitialized
    a2 : [2]int = { 33, 44 }; // Local allocation, initialized

    printf("a1: { %lld, %lld }\n".data, a1[0], a1[1]);
    printf("a2: { %lld, %lld }\n".data, a2[0], a2[1]);

    a1[0] = 90;
    a1[1] = 91;
    a2[0] = 92;
    a2[1] = 93;

    printf("\n".data);
    printf("a1: { %lld, %lld }\n".data, a1[0], a1[1]);
    printf("a2: { %lld, %lld }\n".data, a2[0], a2[1]);

    assert(a1.length == 2);
    assert(a1.data == *a1[0]);

    assert(a2.length == 2);
    assert(a2.data == *a2[0]);

    assert(a1.data != a2.data);

    a1 = { 11, 22 }; // Store in local allocation

    printf("\n".data);
    printf("a1: { %lld, %lld }\n".data, a1[0], a1[1]);
    printf("a2: { %lld, %lld }\n".data, a2[0], a2[1]);

    a1 = a2;         // Store in local allocation, still seperate arrays

    assert(a1.data != a2.data);

    printf("\n".data);
    printf("a1: { %lld, %lld }\n".data, a1[0], a1[1]);
    printf("a2: { %lld, %lld }\n".data, a2[0], a2[1]);

    a3 : [2]int = { add(101, 10), add(202, 20) };

    printf("\n".data);
    printf("a3: { %lld, %lld }\n".data, a3[0], a3[1]);

    a3 = { add(101, 11), add(202, 22) };

    printf("\n".data);
    printf("a3: { %lld, %lld }\n".data, a3[0], a3[1]);
    printf("\n".data);

    array_value_func_1(a1); // Create local copy of a1's elements, pass pointer to function
    assert(a1[0] == 92);
    assert(a1[1] == 93);

    //  a4 := make_array(55, 66); // Create temporary array for return value, pass pointer, assign (memcpy) to variable after return
    //  printf("\n".data);
    //  printf("a4: { %lld, %lld }\n".data, a4[0], a4[1]);

    //  a4 = make_array(66, 77); // Create temporary array for return value, pass pointer, assign (memcpy) to variable after return

    //  invalid1 := <a2; // Disallow dereference

    //  // Create uninitialized local allocation, pass it's pointer
    //  a4 : [2]int;
    //  init_array(*a4, 77, 88);

    //  a5 : *[2]int = heap_array(99, 1010); // Allocate array on heap
    //  assert(a5.length == 2);
    //  assert(a5.data != a4.data);

    return 0;

}

add :: (a: s64, b: s64) -> int { return a + b; }

array_value_func_1 :: (a: [2]int) {

    printf("[enter] array_value_func_1: (%p) { %i, %i }\n".data, a.data, a[0], a[1]);

    a[0] = -1;
    a[1] = -2;

    array_value_func_2(a);

    printf("[exit]  array_value_func_1: (%p) { %i, %i }\n".data, a.data, a[0], a[1]);
}

array_value_func_2 :: (a: [2]int) {
    printf("[enter] array_value_func_2: (%p) { %i, %i }\n".data, a.data,  a[0], a[1]);

    a = { -11, -12 };

    printf("[exit]  array_value_func_2: (%p) { %i, %i }\n".data, a.data,  a[0], a[1]);
}

//  make_array :: (v1: int, v2: int) -> [2]int {
//      return { v1, v2 };
//  }
