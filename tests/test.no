//  - // AST_DECL_FLAG_STORAGE_REQUIRED is only used for arguments/parameters?

//  - Constant variables (aggregates, dissallow modification...)
//  - Basic control flow
//      - switch
//      - defer
//  - Nested function declarations
//  - Cleanup error reporting
//      - seperate creating and submission, this should be cleaner (eg. in valid_cast())

//  - Keyword tokens should be associated with some enum so the parser can switch on this instead of using if-else chains
//  - Redo linear allocator to have blocks
//  - Capture errors, and check for them in tests


// putchar :: (char: s32) -> s32 #foreign;
// puts :: (str: *u8) -> s32 #foreign;
// foreign_add :: (a: s64, b: s64) -> s32 #foreign;
printf :: (format: cstring, ..) -> s32 #foreign;
// malloc :: (size: s64) -> *void #foreign;
// free :: (ptr: *void) -> void #foreign


//  ret_x :: (x: s64) -> int { return x; }
//  add :: (a: s64, b: s64) -> s64 { return a + b; }

//  Vec2 :: struct {
//      x: s64; y: s64;
//  }

//  vec :: (x: s64, y: s64) -> Vec2 { return { x, y }; }

//  main :: () -> s64 {

//      x := 0;
//      x += 1;
//      v := vec(1, 2);
//      printf("{ %lld, %lld }\n".data, v.x, v.y);

//      return 0;
//  }


//  #run main();

putchar :: (char: s32) -> s32 #foreign;
foreign_add :: (a: s64, b: s64) -> s32 #foreign;

glob_1 := 1;
glob_2 : u32 = 2;

// main :: () -> s64 {
//
//     assert(true);
//     printf("Hello, World!\n".data);
//
//     c : s32 = 'H';
//
//
//     c = putchar(c);
//     c2 := putchar('I');
//     putchar('!');
//     putchar('\n');
//
//     assert(c + c2 + foreign_add(glob_1, cast(s64, glob_2)) == 148);
//
//     return 0;
// }

main :: () -> int {

    // unsigned -> unsigned
    assert(cast(u8,  cast(u64, 0x0101010101010111)) == 0x11);
    assert(cast(u16, cast(u64, 0x0101010101011001)) == 0x1001);
    assert(cast(u32, cast(u64, 0x0000000110000001)) == 0x10000001);
    assert(cast(u8,  cast(u32, 0x0101010101010111)) == 0x11);
    assert(cast(u16, cast(u32, 0x0101010101011001)) == 0x1001);
    assert(cast(u8,  cast(u16, 0x0101010101010111)) == 0x11);

    // signed -> unsigned
    assert(cast(u8,            0x0101010101010111)  == 0x11);
    assert(cast(u16,           0x0101010101011001)  == 0x1001);
    assert(cast(u32,           0x0000000110000001)  == 0x10000001);
    assert(cast(u8,  cast(s32, 0x0101010101010111)) == 0x11);
    assert(cast(u16, cast(s32, 0x0101010101011001)) == 0x1001);
    assert(cast(u8,  cast(s16, 0x0101010101010111)) == 0x11);

    // unsigned -> signed
    assert(cast(s8,  cast(u64, 0xfefefefefefefefe)) == 0xfe);
    assert(cast(s16, cast(u64, 0xfefefefefefefefe)) == 0xfefe);
    assert(cast(s32, cast(u64, 0xfefefefefefefefe)) == 0xfefefefe);
    assert(cast(s8,  cast(u32, 0xfefefefefefefefe)) == 0xfe);
    assert(cast(s16, cast(u32, 0xfefefefefefefefe)) == 0xfefe);
    assert(cast(s8,  cast(u16, 0xfefefefefefefefe)) == 0xfe);

    // signed -> signed
    assert(cast(s8,  cast(s64, 0xfefefefefefefefe)) == 0xfe);
    assert(cast(s16, cast(s64, 0xfefefefefefefefe)) == 0xfefe);
    assert(cast(s32, cast(s64, 0xfefefefefefefefe)) == 0xfefefefe);
    assert(cast(s8,  cast(s32, 0xfefefefefefefefe)) == 0xfe);
    assert(cast(s16, cast(s32, 0xfefefefefefefefe)) == 0xfefe);
    assert(cast(s8,  cast(s16, 0xfefefefefefefefe)) == 0xfe);

    return 0;
}
