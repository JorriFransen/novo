// TODO:
//  - VM dynamic register count
//  - VM dynamic stack
//  - VM ALLOC calls malloc right now, DONT! (this is also never freed)
//  - test sign and zero extend
//  - test pointer math
//  - ssa ops for pointer offset and difference
//  - null
//  - pointer casts
//  - sizeof()
//  - Make sure ssa allocs are emitted in variable declaration order
//  - Move FFI to instance?
//  - Free vm?
//  - Foreign functions (call printf)
//  - #run
//  - #insert

//  - Global variables
//  - Constant variables
//  - Basic control flow
//      - switch
//      - defer
//  - Nested function declarations

//  - Keyword tokens should be associated with some enum so the parser can switch on this instead of using if-else chains
//  - Redo linear allocator to have blocks
//  - Capture errors, and check for them in tests


// putchar :: (char: s32) -> s32 #foreign;
// puts :: (str: *u8) -> s32 #foreign;
// foreign_add :: (a: s64, b: s64) -> s32 #foreign;

// main :: () -> int {
//     return foreign_add(1, 2);
// }

Vec :: struct {
    x : s64;
    y : s64;
}

add_v1 :: (a: Vec, b: Vec) -> Vec {
    return { a.x + b.x, a.y + b.y };
}

add_v2 :: (a: Vec, b: Vec) -> Vec {
    r : Vec = { a.x + b.x, a.y + b.y };
    return r;
}

main :: () -> s64 {
    a : Vec = { 1, 2 };
    r := add_v1(a, { 11, 22 });
    //
    // r = add_v2(r, { 2, 3 });
    //
    // assert(r.x + r.y == 41);

    return 0;
}
