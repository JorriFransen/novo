// TODO:
//  - unary -
//  - sizeof()
//  - Make sure ssa allocs are emitted in varaible declaration order
//  - Move FFI to instance?
//  - Free vm?
//  - Foreign functions (call printf)
//  - #run
//  - #insert

//  - Global variables
//  - Constant variables
//  - Basic control flow
//      - switch
//      - defer
//  - Nested function declarations

//  - Keyword tokens should be associated with some enum so the parser can switch on this instead of using if-else chains
//  - Redo linear allocator to have blocks
//  - Capture errors, and check for them in tests


putchar :: (char: s32) -> s32 #foreign;
// puts :: (str: *u8) -> s32 #foreign;
foreign_add :: (a: s64, b: s64) -> s32 #foreign;

main :: () -> s64 {

    msg : string = "Hello, World!";
    msg2 : string = "Hello, World!";
    msg3 : string = "Hello, World";

    // puts(msg.data);
    // puts(msg2.data);
    // puts(msg3.data);

    put_string(msg);
    put_string(msg2);
    put_string(msg3);

    return foreign_add(msg.length, msg3.length);
}

put_string :: (s: string) {
    ptr := s.data;
    for i := 0; i < s.length; i += 1; {

        putchar(cast(s32, <ptr));
        ptr = ptr + 1;
    }
}

