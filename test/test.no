// TODO:
//  - bitcast bytecode instruction (will be required if the backend needs to know register types.)
//  - test pointer math (requires arrays and/or sizeof())
//  - align types
//  - sizeof(), alignof(), offsetof()
//  - Make sure ssa allocs are emitted in variable declaration order
//  - Move FFI to instance?
//  - Free vm?
//  - Foreign functions varargs (call printf)
//  - #run
//  - #insert

//  - Global variables
//  - Constant variables
//  - Basic control flow
//      - switch
//      - defer
//  - Nested function declarations
//  - Cleanup error reporting
//      - seperate creating and submission, this should be cleaner (eg. in valid_cast())

//  - Keyword tokens should be associated with some enum so the parser can switch on this instead of using if-else chains
//  - Redo linear allocator to have blocks
//  - Capture errors, and check for them in tests


putchar :: (char: s32) -> s32 #foreign;
// puts :: (str: *u8) -> s32 #foreign;
// foreign_add :: (a: s64, b: s64) -> s32 #foreign;

main :: () -> int {

    str := "abcd\n";
    end : *u8 = null;
    start := str.data;
    end = start + str.length;

    assert(end - str.length == start);

    {
        c := start;
        while (c != end) {
            putchar(cast(s32, <c));
            c += 1;
        }
    }

    ustart := cast(u64, start);
    uend := cast(u64, end);

    assert(cast(s64, uend - ustart) == str.length);

    {
        c := cast(*u8, ustart);
        while (c != end) {
            putchar(cast(s32, <c));
            c += 1;
        }
    }

    return end - start;
}

